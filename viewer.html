<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <title>Chart Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="styles.css">
  <style>
    body {
      touch-action: none; /* prevent zooming UI on mobile */
    }
    input[type=range] {
      touch-action: pan-y;
    }
  </style>
</head>
<body class="bg-gray-900 text-white">

  <!-- Image Wrapper -->
  <div id="image-wrapper">
    <img id="chart-image" src="" alt="Chart">
  </div>

  <!-- Navigation Buttons -->
  <div class="absolute top-4 left-4 flex gap-2 z-10">
    <a id="back-button" href="#" class="bg-black bg-opacity-50 hover:bg-opacity-70 text-white px-3 py-1 rounded shadow text-sm">‚Üê Back</a>
    <a href="index.html" class="bg-black bg-opacity-50 hover:bg-opacity-70 text-white px-3 py-1 rounded shadow text-sm">üè† Home</a>
  </div>

  <!-- Zoom Buttons -->
  <div class="absolute top-4 right-4 flex flex-col sm:flex-row gap-2 z-10">
    <button id="zoom-in" class="bg-black bg-opacity-50 hover:bg-opacity-70 text-white px-3 py-1 rounded shadow text-sm">Zoom In</button>
    <button id="zoom-out" class="bg-black bg-opacity-50 hover:bg-opacity-70 text-white px-3 py-1 rounded shadow text-sm">Zoom Out</button>
  </div>

  <!-- Zoom Slider -->
  <div class="fixed bottom-6 left-0 right-0 px-4 flex justify-center items-center z-10">
    <div class="bg-black bg-opacity-40 px-4 py-2 rounded-lg w-full max-w-sm">
      <input type="range" id="zoom-slider" min="0.1" max="5" step="0.01" value="1"
             class="w-full h-2 rounded-lg appearance-none cursor-pointer accent-blue-500">
    </div>
  </div>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const imgPath = urlParams.get('img');
    const image = document.getElementById("chart-image");
    const wrapper = document.getElementById("image-wrapper");
    image.src = imgPath;

    // Handle Back button
    const backBtn = document.getElementById("back-button");
    let lastPage = sessionStorage.getItem("lastCategoryURL");
    if (!lastPage || lastPage.endsWith("index.html") || lastPage.endsWith("index.html#home")) {
      lastPage = "index.html#home";
    }
    backBtn.href = lastPage;
    console.log("Back button will go to:", lastPage);

    // Zoom functionality
    let scale = 1;
    const zoomStep = 0.25;
    const minZoom = 0.1;
    const maxZoom = 5;
    let offsetX = 0, offsetY = 0;
    let isDragging = false;
    let startX = 0, startY = 0;

    function applyTransform() {
      image.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
      document.getElementById("zoom-slider").value = scale.toFixed(2);
    }

    document.getElementById("zoom-in").onclick = () => {
      scale = Math.min(scale + zoomStep, maxZoom);
      applyTransform();
    };
    document.getElementById("zoom-out").onclick = () => {
      scale = Math.max(scale - zoomStep, minZoom);
      applyTransform();
    };
    document.getElementById("zoom-slider").addEventListener("input", (e) => {
      scale = parseFloat(e.target.value);
      applyTransform();
    });

    wrapper.addEventListener("mousedown", (e) => {
      isDragging = true;
      startX = e.clientX - offsetX;
      startY = e.clientY - offsetY;
      wrapper.style.cursor = "grabbing";
    });
    document.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      offsetX = e.clientX - startX;
      offsetY = e.clientY - startY;
      applyTransform();
    });
    document.addEventListener("mouseup", () => {
      isDragging = false;
      wrapper.style.cursor = "grab";
    });
    document.addEventListener("mouseleave", () => {
      isDragging = false;
      wrapper.style.cursor = "grab";
    });

    document.addEventListener("keydown", (e) => {
      if (e.key === '+' || e.key === '=') {
        scale = Math.min(scale + zoomStep, maxZoom);
        applyTransform();
      } else if (e.key === '-') {
        scale = Math.max(scale - zoomStep, minZoom);
        applyTransform();
      }
    });

    // Touch support
    let lastTouchDistance = null;
    wrapper.addEventListener("touchstart", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDistance = Math.hypot(dx, dy);
      } else if (e.touches.length === 1) {
        startX = e.touches[0].clientX - offsetX;
        startY = e.touches[0].clientY - offsetY;
        isDragging = true;
      }
    }, { passive: false });

    wrapper.addEventListener("touchmove", (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const newDistance = Math.hypot(dx, dy);
        if (lastTouchDistance) {
          const zoomChange = newDistance / lastTouchDistance;
          scale = Math.min(Math.max(scale * zoomChange, minZoom), maxZoom);
          lastTouchDistance = newDistance;
          applyTransform();
        }
      } else if (e.touches.length === 1 && isDragging) {
        offsetX = e.touches[0].clientX - startX;
        offsetY = e.touches[0].clientY - startY;
        applyTransform();
      }
    }, { passive: false });

    wrapper.addEventListener("touchend", (e) => {
      if (e.touches.length < 2) {
        lastTouchDistance = null;
      }
      if (e.touches.length === 0) {
        isDragging = false;
        wrapper.style.cursor = "grab";
      }
    });

    applyTransform();
  </script>
</body>
</html>
